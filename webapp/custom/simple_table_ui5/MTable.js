sap.ui.define(	[		'jquery.sap.global',		'sap/ui/core/Control',		'./library',		"sap/m/Table",		"sap/m/Input",		"sap/m/Label",		"sap/m/Column",		"/sap/m/ColumnListItem",		"/sap/m/DatePicker",		"/sap/m/DateTimePicker"	],	function(jQuery, Control, library, Table, Input, Label, Column, ColumnListItem, DatePicker, DateTimePicker) {		"use strict";		var MTable = Table.extend('custom.simple_table_ui5.MTable', {			// metadata section defines the API of the control (properties, events, aggregations; automatically			// creates convenience functions)			metadata: {				library: 'custom.simple_table_ui5',				properties: {					fieldProperties: {						type: "any"					},					items: {						type: "any"					},					editable: {						type: "boolean",						defaultValue: false					},					dateValueFormat: {						type: "string",						defaultValue: "yyyy-MM-dd"					},					dateTimeValueFormat: {						type: "string",						defaultValue: "yyyy-MM-ddThh:mm:ss"					}				}			},			renderer: {} // just inherit sap.m.TableRenderer		});				MTable.prototype.onBeforeRendering = function(oJQueryEvent) {			// if columns aggregation and column template are declared in XML View, use them; otherwise generate default 			// using the fieldProperties metadata			if (!this.getBindingInfo('columns')) {				var oColumn = new Column();				// generate header template				var oText = new Label({});				oText.bindProperty('text', {					path: 'name',					model: this.getBindingInfo('fieldProperties').parts[0].model				});				oText.bindProperty('design', {					path: 'primary_key',					model: this.getBindingInfo('fieldProperties').parts[0].model,					formatter: function(bPrimaryKey) {						if (bPrimaryKey) {							return 'Bold';						} else {							return 'Standard';						}					}				});				oColumn.setHeader(oText);				this.bindAggregation('columns', {					path: this.getBindingInfo('fieldProperties').parts[0].path,					model: this.getBindingInfo('fieldProperties').parts[0].model,					template: oColumn,					templateShareable: false				});			}			// if a row template is declared in XML View, use it; otherwise generate default one 			// in either case, set factory function for generating the individual cells' controls, i.e. cells aggregation			// using the fieldProperties metadata			if (this.getBindingInfo('items') && this.getBindingInfo('items').template) {				var oColumnListItem = this.getBindingInfo('items').template;			} else {				oColumnListItem = new ColumnListItem();				this.bindAggregation('items', {					path: this.getBindingInfo('items').parts[0].path,					model: this.getBindingInfo('items').parts[0].model,					template: oColumnListItem,					templateShareable: false				});			}			oColumnListItem.bindAggregation("cells", {				path: this.getBindingInfo('fieldProperties').parts[0].path,				model: this.getBindingInfo('fieldProperties').parts[0].model,				templateShareable: false,				factory: this.tableColumnsFactory.bind(this)			});		};		MTable.prototype.tableColumnsFactory = function(sId, oContext) {			// create specific control depending on the datatype 			switch(oContext.getObject().datatype){				case 'date':					var oInput = new DatePicker({valueFormat: this.getDateValueFormat()});					break;				case 'datetime':					oInput = new DateTimePicker({valueFormat: this.getDateTimeValueFormat()});					break;				case 'decimal':				case 'integer':					oInput = new Input({type: 'Number'});					break;								default:					oInput = new Input({type: 'Text'});			}						oInput.setVisible(true);			oInput.setEnabled(true);									oInput.bindProperty('value', 'table_data>' + oContext.getObject().name);			// set editable to false for read-only fields (autoincremented ids) 			// otherwise either use mtable's editable binding or set the property statically 			if (oContext.getObject().read_only) {				oInput.setProperty('editable', false);							} else if (this.getBindingInfo('editable')) {				oInput.bindProperty('editable', {					path: this.getBindingInfo('editable').parts[0].path,					model: this.getBindingInfo('editable').parts[0].model				});							} else {				oInput.setProperty('editable', this.getEditable()); // not updated upon MTable.setEditable; use property binding if required			}			// limit text length if a limit is supplied			if (oContext.getObject().length) {				oInput.setMaxLength(oContext.getObject().length);			}						// attach input check for fields not nullable			if (!oContext.getObject().nullable && !oContext.getObject().read_only === true) {				oInput.setFieldGroupIds('not_nullable');				if(['date', 'datetime'].includes(oContext.getObject().datatype)){					oInput.attachChange(this.onLiveChangeInputRequired);				} else {					oInput.attachLiveChange(this.onLiveChangeInputRequired);				}			}			return oInput;		};				MTable.prototype.onLiveChangeInputRequired = function(oEvent){			if(!oEvent.getParameter('newValue') || oEvent.getParameter('newValue').length === 0){				oEvent.getSource().setValueState('Error');				oEvent.getSource().setValueStateText('Mandatory');			} else {				oEvent.getSource().setValueState('None');				oEvent.getSource().setValueStateText('');			}		};				MTable.prototype.addRow = function(oEvent){			// add an empty record to the table data model with each field being existent but empty 			// get current controls bound to fields flagged as not nullable			var aControlsOld = this.getControlsByFieldGroupId('not_nullable');						// append empty row to rows in model			var aRows = this.getBindingContext(this.getBindingInfo('items').model).getObject().rows;			aRows.push(this._getEmptyRow());			this.getBinding('items').getModel().updateBindings();						// determine the newly instantiated controls which are not nullable to show validation text			var aControlsNew = this.getControlsByFieldGroupId('not_nullable');			var iNew = aControlsNew.length - aControlsOld.length;			if (iNew === 0){				return;			}						// ... and trigger the liveChange event			for (var i = 0; i < iNew; i++){				aControlsNew[aControlsNew.length-i-1].fireLiveChange();				}		};				MTable.prototype._getEmptyRow = function(){			// generate dict with empty values specified by current table metadata			var aColumns = this.getBindingContext(this.getBindingInfo('fieldProperties').parts[0].model).getObject().columns;			var oRow = {};			for(var i = 0; i < aColumns.length; i++){				oRow[aColumns[i].name] = '';				}			return oRow;		};				MTable.prototype.validateContent = function(){			// validate content of table data (currently only if non-nullable entries are filled)			// get not-nullable fields from metadata			var aColumns = this.getBindingContext(this.getBindingInfo('fieldProperties').parts[0].model).getObject().columns;			var aColumnsNotNullable = [];			for (var i = 0; i < aColumns.length; i++){				if(aColumns[i].nullable === false && !aColumns[i].read_only ){					aColumnsNotNullable.push(aColumns[i].name);				}			}			// loop through the rows and check if all not-nullable fields are filled			var mValidation = {missing: 0};			var aRows = this.getBindingContext(this.getBindingInfo('items').model).getObject().rows;			aRows.forEach(function(oRow){				aColumnsNotNullable.forEach(function(sField){					if (oRow[sField] === ''){						mValidation.missing++;						}				});			});			return mValidation;		};		return MTable;	}, true);